## 面向对象思想设计原则

>在实际的开发中，我们要想更深入的了解面向对象思想，就必须熟悉前人总结过的面向对象的思想的设计原则

* 单一职责原则
	* 其实就是开发人员经常说的”高内聚，低耦合”也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则。
* 开闭原则
	* 核心思想是：一个对象对扩展开放，对修改关闭。其实开闭原则的意思就是：对类的改动是通过增加代码进行的，而不是修改现有代码。也就是说软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。

* 里氏替换原则
	* 核心思想：在任何父类出现的地方都可以用它的子类来替代。其实就是说：同一个继承体系中的对象应该有共同的行为特征。

* 依赖注入原则
	* 核心思想：要依赖于抽象，不要依赖于具体实现。其实就是说：在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。

* 接口分离原则
	* 核心思想：不应该强迫程序依赖它们不需要使用的方法。其实就是说：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
* 迪米特原则
	* 核心思想：一个对象应当对其他对象尽可能少的了解其实就是说：降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用

## 设计模式

* 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
* 设计模式不是一种方法和技术，而是一种思想
* 设计模式和具体的语言无关，学习设计模式就是要建立面向对象的思想，尽可能的面向接口编程，低耦合，高内聚，使设计的程序可复用
* 学习设计模式能够促进对面向对象思想的理解，反之亦然。它们相辅相成


### 设计模式分类

创建型模式：简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式。(6个)

结构型模式：外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)

行为型模式：模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式。(10个)

##创建新模式
### 简单工厂模式

>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例

* 优点

客户端不需要在负责对象的创建，从而明确了各个类的职责

* 缺点

这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要**不断的修改工厂类**，不利于后期的维护

代码例子：
	
	public class AnimalFactory {
	
		private AnimalFactory() {
		}	
		public static Animal createAnimal(String type) {
			if ("dog".equals(type)) {
				return new Dog();
			} else if ("cat".equals(type)) {
				return new Cat();
			} else {
				return null;
			}
		}
	}

	public static void main(String[] args) {
			// 工厂
			Animal a = AnimalFactory.createAnimal("dog");
			a.eat();
			a = AnimalFactory.createAnimal("cat");
			a.eat();
	
			// NullPointerException
			a = AnimalFactory.createAnimal("pig");
			if (a != null) {
				a.eat();
			} else {
				System.out.println("对不起，暂时不提供这种动物");
			}
		}

### 工厂方法模式

>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由**继承抽象工厂**的具体类实现。

* 优点

客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

* 缺点

需要额外的编写代码，增加了工作量

代码例子：

	public interface Factory {
		public abstract Animal createAnimal();
	}
	
	public class CatFactory implements Factory {
	
		@Override
		public Animal createAnimal() {
			return new Cat();
		}
	
	}
	
	public class DogFactory implements Factory {
	
		@Override
		public Animal createAnimal() {
			return new Dog();
		}
	
	}
	
	public static void main(String[] args) {
			// 需求：我要买只狗
			Factory f = new DogFactory();
			Animal a = f.createAnimal();
			a.eat();
			System.out.println("-------");
			
			//需求：我要买只猫
			f = new CatFactory();
			a = f.createAnimal();
			a.eat();
		}
	
## 单例模式

>单例模式就是要确保类在内存中**只有一个对象**，该实例必须自动创建，并且对外提供。

* 优点

在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。

* 缺点

没有抽象层，因此扩展很难。职责过重，在一定程序上违背了单一职责。

单例模式是如何保证内存中只有一个对象呢?

A：把构造方法私有-->B:在成员位置自己创建一个对象-->C:通过一个公共的方法提供访问

代码例子：

**饿汉式**：类一加载就造对象

	public class Student {
		// 构造私有
		private Student() {
		}
	
		// 自己造一个
		// 静态方法只能访问静态成员变量，加静态
		// 为了不让外界直接访问修改这个值，加private
		private static Student s = new Student();
	
		// 提供公共的访问方式
		// 为了保证外界能够直接使用该方法，加静态
		public static Student getStudent() {
			return s;
		}
		}
		Student.s = null;

		Student s1 = Student.getStudent();
		Student s2 = Student.getStudent();
		System.out.println(s1 == s2);

		System.out.println(s1);  // null，cn.xianglei.Student@175078b
		System.out.println(s2); // null，cn.xianglei.Student@175078b

	这里如果private static Student s = new Student();不是私有变量，外界可以改变它的值使他为空。

**懒汉式**：用的时候才去创建对象

	public class Teacher {
		private Teacher() {
		}
	
		private static Teacher t = null;
	
		public synchronized static Teacher getTeacher() {
			// t1,t2,t3  		第一次的时候造对象
			if (t == null) {
				//t1,t2,t3
				t = new Teacher();
			}
			return t;
		}
	}

当多个线程 如t1 t2 t3 依次来会创建三次对象，此时线程不安全。

**面试题**：单例模式的思想是什么?Runtime(每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接，执行dos命令等)。类也是一个饿汉试单例模式。由此可见开发中较多使用的是饿汉式。

>单例模式就是要确保类在内存中**只有一个对象**，该实例必须自动创建，并且对外提供。


 * 	开发中：饿汉式(是不会出问题的单例模式)
 * 	面试中：懒汉式(可能会出问题的单例模式)
 	* 	A:懒加载(延迟加载)	
 	* 	B:线程安全问题，何时会出现？
 		* 	a:多线程环境	
 		* 	b:有共享数据	
 		* 	c:有多条语句操作共享数据 	

